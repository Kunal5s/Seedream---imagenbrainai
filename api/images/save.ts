// api/images/save.ts
import type { VercelRequest, VercelResponse } from '@vercel/node';
import { db } from '../../services/firebase';
import { uploadImageToR2 } from '../../services/r2';
import { ImageRecord } from '../../services/apiService';
import { GoogleGenAI, Type } from '@google/genai';
import { UserStatus } from '../../services/licenseService';
import { PLAN_DETAILS } from '../../config/plans';
import { verifyFirebaseToken } from '../../services/auth';

const PURCHASE_LINK = 'https://buy.polar.sh/polar_cl_Dq1dKRQK58YEweEc0gwvPacYvNAY9ANcV34G36N0';
const HISTORY_LIMIT = 30;

const getRandomPrice = () => {
    const roll = Math.random();
    if (roll < 0.05) return Math.floor(Math.random() * (1000 - 501 + 1)) + 501;
    if (roll < 0.15) return Math.floor(Math.random() * (500 - 151 + 1)) + 151;
    return Math.floor(Math.random() * (150 - 20 + 1)) + 20;
};

async function generateMarketplaceMetadata(prompt: string): Promise<{ title: string; description: string }> {
    if (!process.env.API_KEY) {
        return { 
            title: 'Intriguing AI Generated Masterpiece', 
            description: 'This captivating artwork, born from a digital mind, offers a unique glimpse into the boundless possibilities of creative artificial intelligence for your collection.' 
        };
    }
    try {
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: `Based on the following image prompt, generate metadata for an art marketplace. Prompt: "${prompt}"`,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        title: { type: Type.STRING, description: 'An engaging, creative title, exactly 6 words long.' },
                        description: { type: Type.STRING, description: 'A compelling, descriptive summary of the artwork, exactly 23 words long.' }
                    },
                    required: ["title", "description"]
                }
            }
        });
        const metadata = JSON.parse(response.text.trim());
        return { title: metadata.title, description: metadata.description };
    } catch (error) {
        console.error("Error generating metadata with Gemini:", error);
        return {
            title: 'Captivating and Unique AI Artwork',
            description: 'Explore a visually stunning piece generated by advanced AI, perfect for any digital art enthusiast looking to own a truly one-of-a-kind creation.'
        };
    }
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
    if (req.method !== 'POST') {
        res.setHeader('Allow', ['POST']);
        return res.status(405).end(`Method ${req.method} Not Allowed`);
    }

    const { base64Image, prompt, fullPrompt, width, height, isPremium } = req.body;
    if (!base64Image || !prompt || !fullPrompt || !width || !height) {
        return res.status(400).json({ message: 'Missing required image data for saving.' });
    }
    
    // Guest users don't need a token, but licensed users do.
    const decodedToken = isPremium ? await verifyFirebaseToken(req) : null;
    if (isPremium && !decodedToken) {
        return res.status(401).json({ message: 'Unauthorized: A valid user session is required for premium generation.' });
    }
    const userId = decodedToken ? decodedToken.uid : 'guest_user';


    try {
        const imagesRef = db.collection('images');
        let finalCredits = 0;

        if (isPremium && userId !== 'guest_user') {
            const userRef = db.collection('users').doc(userId);
            const newCreditTotal = await db.runTransaction(async (transaction) => {
                const userDoc = await transaction.get(userRef);
                if (!userDoc.exists) throw new Error('User not found for credit deduction.');
                
                const userData = userDoc.data() as UserStatus;
                const planKey = Object.keys(PLAN_DETAILS).find(k => PLAN_DETAILS[k].name === userData.plan) || 'FREE_TRIAL';
                const creditsNeeded = (PLAN_DETAILS[planKey]?.creditsPerImage || 5) * 4;

                if (userData.credits < creditsNeeded) {
                    throw new Error('Insufficient credits.');
                }
                
                const newTotal = userData.credits - creditsNeeded;
                transaction.update(userRef, { credits: newTotal });
                return newTotal;
            });
            finalCredits = newCreditTotal;
        }

        const r2Url = await uploadImageToR2(base64Image, userId);
        const now = new Date();
        const newImageData = {
            url: r2Url, prompt, fullPrompt, width, height,
            createdAt: now.toISOString(), userId: userId,
            marketplaceStatus: 'private' as const,
            price: null, purchaseLink: null, title: null, description: null,
        };
        const newImageRef = await imagesRef.add(newImageData);

        // Marketplace logic only for non-premium (guest/free) generations from real users
        if (!isPremium && userId !== 'guest_user') {
            const userImagesSnapshot = await imagesRef
                .where('userId', '==', userId)
                .where('marketplaceStatus', '==', 'private')
                .orderBy('createdAt', 'asc').get();

            if (userImagesSnapshot.docs.length > HISTORY_LIMIT) {
                const oldestDoc = userImagesSnapshot.docs[0];
                const metadata = await generateMarketplaceMetadata(oldestDoc.data().fullPrompt);
                await oldestDoc.ref.update({
                    marketplaceStatus: 'live', price: getRandomPrice(),
                    purchaseLink: PURCHASE_LINK, title: metadata.title, description: metadata.description
                });
            }
        }
        
        const savedRecord: ImageRecord = { ...newImageData, id: newImageRef.id };
        res.status(200).json({ savedRecord, credits: finalCredits });

    } catch (error) {
        console.error("Image saving error:", error);
        const msg = error instanceof Error ? error.message : "Unknown server error during save.";
        res.status(500).json({ success: false, message: msg });
    }
}